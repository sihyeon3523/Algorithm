# 피보나치 수열을 재귀함수로 구현하면
# x값이 커짐에 따라 연산 수행시간이 기하급수 적으로 늘어난다
'''
import time

def fibo(x):
    if x == 1 or x == 2:
        return 1 
    
    return fibo(x-1) + fibo(x-2)

for num in range(5, 40, 10):
    start = time.time()
    res = fibo(num)
    print(res, '--> 러닝타임', round(time.time()-start,2), '초')

5 --> 러닝타임 0.0 초
610 --> 러닝타임 0.0 초
75025 --> 러닝타임 0.01 초
9227465 --> 러닝타임 1.67 초
'''

# 연산 수행시간이 늘어나는 문제를 해결하기 위해 다이나믹 프로그래밍을 사용
# 다이나믹 프로그래밍의 포인트는 한번 결과를 수행한 것을 메모리에
# 저장해놓고 다음에 똑같은 결과가 필요하면 그 때 다시 연산하지 않고
# 메모리에 저장된 그 값을 가져와 쓰는 것
# --> 메모제이션(캐싱) 기법

# 재귀함수를 사용해 구현하는 다이나믹 프로그래밍 방법은
# 메모제이션 기법을 활용한 Top-Down 방식
# 즉, 큰 문제를 해결하기 위해 작은 문제를 호출하는 것
'''
import time

d = [0] * 50

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

for num in range(5, 40, 10):
    start = time.time()
    res = fibo(num)
    print(res, '--> 러닝타임', round(time.time()-start, 2), '초')


5 --> 러닝타임 0.0 초
610 --> 러닝타임 0.0 초
75025 --> 러닝타임 0.0 초
9227465 --> 러닝타임 0.0 초
'''

# 단순 반복문을 사용해 다이나믹 프로그래밍 구현
# 작은 문제부터 차근차근 답을 도출해서 큰 문제를 해결한다고 하여
# Bottom-Up 방식이라고 한다. 
# Top-Down 방식에서는 이미 수행한 결과를 저장하는 것을 메모제이션
# Bottom-up 방식에서는 DP 테이블이라고 한다. 

d = [0] * 100

d[1] = 1
d[2] = 1
N = 99 

for i in range(3, N+1):
    d[i] = d[i-1] + d[i-2]

print(d[N])

# Top-Down 방식의 메모제이션 기법은 사전 자료형을 이용할 수도 있는데
# 이는 수열처럼 연속적이지 않은 자료가 주어질 때 유용하다고 한다. 
# 나동빈씨는 단순 반복문을 사용하는 Bottom-Up 방식으로 DP 문베를 해결하라고 권장
# 재귀함수를 이용하는 Top-Down 방식을 사용하다보면 재귀 횟수 제한 오류가 걸릴 수 있기 때문
# 물론 이러한 오류가 나타났을 때 sys 라이브러리의 setrecursionlimit() 메서드를 호출해서
# 재귀 제한 횟수를 늘려주는 방법도 있다고 한다. 